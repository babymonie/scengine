{
  "version": 3,
  "sources": ["../index.js"],
  "sourcesContent": ["const axios = require(\"axios\");\r\nconst fs = require(\"fs\");\r\nconst cheerio = require(\"cheerio\");\r\nconst { URL } = require(\"url\");\r\nconst crypto = require(\"crypto\"); // For hashing the script\r\nconst requestCache = new Map();\r\nconst DEFAULT_TTL = 1000 * 60 * 5; // 5 minutes\r\n\r\nfunction getScriptHash(scriptContent) {\r\n  return crypto.createHash(\"md5\").update(scriptContent).digest(\"hex\");\r\n}\r\n\r\nfunction getCacheKey(url, scriptHash) {\r\n  return `${url}::${scriptHash}`;\r\n}\r\n\r\nfunction getCached(cacheKey) {\r\n  const entry = requestCache.get(cacheKey);\r\n  if (!entry) return null;\r\n  if (Date.now() > entry.expireAt) {\r\n    requestCache.delete(cacheKey);\r\n    return null;\r\n  }\r\n  return entry.data;\r\n}\r\n\r\nfunction setCached(cacheKey, data, ttl = DEFAULT_TTL) {\r\n  requestCache.set(cacheKey, {\r\n    data,\r\n    expireAt: Date.now() + ttl,\r\n  });\r\n}\r\n\r\nasync function fetchWithCache(url, scriptHash, axiosConfig = {}, ttl = DEFAULT_TTL) {\r\n  const cacheKey = getCacheKey(url, scriptHash);\r\n  const cached = getCached(cacheKey);\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n  const response = await axios.get(url, axiosConfig);\r\n  setCached(cacheKey, response.data, ttl);\r\n  return response.data;\r\n}\r\nconst transformFunctions = {\r\n  trim: (val, $) => (typeof val === \"string\" ? val.trim() : val),\r\n  toLowerCase: (val, $) => (typeof val === \"string\" ? val.toLowerCase() : val),\r\n  toUpperCase: (val, $) => (typeof val === \"string\" ? val.toUpperCase() : val),\r\n  default: (val, $, defaultVal) => (val == null || val === \"\" ? defaultVal : val),\r\n  regex: (val, $, pattern, group = \"0\") => {\r\n    if (typeof val !== \"string\") return val;\r\n    const re = new RegExp(pattern);\r\n    const match = val.match(re);\r\n    if (match) {\r\n      const index = parseInt(group);\r\n      return match[index] || val;\r\n    }\r\n    return val;\r\n  },\r\n  dateParse: (val, $) => {\r\n    const date = new Date(val);\r\n    return isNaN(date.getTime()) ? val : date.toISOString();\r\n  },\r\n  customJS: (val, $, code) => {\r\n    try {\r\n      const fn = new Function(\"value\", code);\r\n      return fn(val);\r\n    } catch (e) {\r\n      return val;\r\n    }\r\n  },\r\n  regexReplace: (val, $, pattern, replacement) => {\r\n    if (typeof val !== \"string\") return val;\r\n    pattern = pattern.replace(/\\\\\\\\/g, '\\\\');\r\n    const re = new RegExp(pattern);\r\n    return val.replace(re, replacement);\r\n  },\r\n};\r\n\r\nfunction cleanResult(value, $) {\r\n  if (Array.isArray(value)) {\r\n    return value.map((item) => cleanResult(item, $));\r\n  } else if (typeof value === \"object\" && value !== null) {\r\n    if (value.type && value.children) {\r\n      return $(value).text();\r\n    }\r\n    let newObj = {};\r\n    for (let key in value) {\r\n      newObj[key] = cleanResult(value[key], $);\r\n    }\r\n    return newObj;\r\n  } else {\r\n    return value;\r\n  }\r\n}\r\n\r\nfunction parseBlock(lines, startIndex) {\r\n  let blockLines = [];\r\n  let braceCount = 1;\r\n  let i = startIndex;\r\n  while (i < lines.length && braceCount > 0) {\r\n    const line = lines[i];\r\n    if (line.endsWith(\"{\")) {\r\n      braceCount++;\r\n      blockLines.push(line);\r\n    } else if (line === \"}\") {\r\n      braceCount--;\r\n      if (braceCount > 0) blockLines.push(line);\r\n    } else {\r\n      blockLines.push(line);\r\n    }\r\n    i++;\r\n  }\r\n  return { blockText: blockLines.join(\"\\n\"), newIndex: i };\r\n}\r\n\r\nfunction parseScript(script) {\r\n  script = script.trim();\r\n  const match = script.match(/^([^\\{]+)\\{([\\s\\S]+)\\}\\s*$/);\r\n  if (!match) {\r\n    throw new Error(\"Invalid script format. Ensure the Scengine is enclosed in { }.\");\r\n  }\r\n  const headerParts = match[1].trim().split(\"|\").map((s) => s.trim());\r\n  const url = headerParts[0];\r\n  const config = {};\r\n  for (let i = 1; i < headerParts.length; i++) {\r\n    const [key, value] = headerParts[i].split(\"=\");\r\n    if (key && value) {\r\n      config[key.trim()] = value.trim();\r\n    }\r\n  }\r\n  const instructionsText = match[2].trim();\r\n  const instructions = parseInstructions(instructionsText);\r\n  return { url, config, instructions };\r\n}\r\n\r\nfunction parseInstructions(text) {\r\n  text = text.replace(/}\\s*else\\s*{/g, \"}\\nelse {\");\r\n  const lines = text\r\n    .split(\"\\n\")\r\n    .map((line) => line.trim())\r\n    .filter((line) => line && !line.startsWith(\"//\"));\r\n\r\n  const instructions = [];\r\n  let i = 0;\r\n  while (i < lines.length) {\r\n    let line = lines[i];\r\n    if (/^if\\s*\\(.*\\)\\s*\\{$/.test(line)) {\r\n      const conditionMatch = line.match(/^if\\s*\\((.*)\\)\\s*\\{$/);\r\n      if (!conditionMatch) throw new Error(`Invalid if condition: ${line}`);\r\n      const condition = conditionMatch[1];\r\n      i++;\r\n      const { blockText, newIndex } = parseBlock(lines, i);\r\n      const ifInstructions = parseInstructions(blockText);\r\n      i = newIndex;\r\n      let elseInstructions = null;\r\n      if (i < lines.length && /^else\\s*\\{$/.test(lines[i])) {\r\n        i++;\r\n        const { blockText: elseBlock, newIndex: elseNewIndex } = parseBlock(lines, i);\r\n        elseInstructions = parseInstructions(elseBlock);\r\n        i = elseNewIndex;\r\n      }\r\n      instructions.push({\r\n        type: \"conditional\",\r\n        condition,\r\n        ifInstructions,\r\n        elseInstructions,\r\n      });\r\n      continue;\r\n    }\r\n    if (line.endsWith(\":{\")) {\r\n      const assignVar = line.slice(0, -2).trim();\r\n      i++;\r\n      const { blockText, newIndex } = parseBlock(lines, i);\r\n      const nestedInstructions = parseInstructions(blockText);\r\n      instructions.push({\r\n        type: \"block\",\r\n        assign: assignVar,\r\n        instructions: nestedInstructions,\r\n      });\r\n      i = newIndex;\r\n      continue;\r\n    }\r\n    {\r\n      let exclude = false;\r\n      if (line.startsWith(\"!\")) {\r\n        exclude = true;\r\n        line = line.slice(1).trim();\r\n      }\r\n      const parts = line.split(\"=\");\r\n      if (parts.length !== 2) {\r\n        throw new Error(`Invalid instruction: ${line}`);\r\n      }\r\n      const lhs = parts[0].trim();\r\n      let assignPart = parts[1].trim();\r\n      let assignVar, transforms = [];\r\n      if (assignPart.includes(\"|\")) {\r\n        const tokens = assignPart.split(\"|\").map((s) => s.trim());\r\n        assignVar = tokens[0];\r\n        transforms = tokens.slice(1).map((token) => {\r\n          const m = token.match(/^(\\w+)(?:\\((.*)\\))?$/);\r\n          if (m) {\r\n            return {\r\n              fn: m[1],\r\n              params: m[2]\r\n                ? m[2].split(\",\").map((s) => s.trim().replace(/^[\"']|[\"']$/g, \"\"))\r\n                : [],\r\n            };\r\n          }\r\n          return { fn: token, params: [] };\r\n        });\r\n      } else {\r\n        assignVar = assignPart;\r\n      }\r\n      let literalValue = null;\r\n      if (\r\n        (lhs.startsWith('\"') && lhs.endsWith('\"')) ||\r\n        (lhs.startsWith(\"'\") && lhs.endsWith(\"'\"))\r\n      ) {\r\n        literalValue = lhs.slice(1, -1);\r\n      }\r\n      let chainParts = null;\r\n      let attribute = null;\r\n      if (!literalValue) {\r\n        const originalChainParts = lhs.split(\">\").map((s) => s.trim());\r\n        chainParts = originalChainParts.map((part) =>\r\n          part.includes(\"..\") ? part.replace(/\\.\\./g, \".\") : part\r\n        );\r\n        const lastTokenOriginal = originalChainParts[originalChainParts.length - 1];\r\n        if (!lastTokenOriginal.startsWith('.') && lastTokenOriginal.includes(\".\")) {\r\n          const parts = lastTokenOriginal.split(\".\");\r\n          chainParts[chainParts.length - 1] = parts[0].trim();\r\n          attribute = parts[1].trim();\r\n        }\r\n      }\r\n      if (literalValue !== null) {\r\n        instructions.push({\r\n          type: \"literal\",\r\n          literal: literalValue,\r\n          assign: assignVar,\r\n          transforms,\r\n          exclude,\r\n        });\r\n      } else {\r\n        instructions.push({\r\n          type: \"extract\",\r\n          exclude,\r\n          chain: chainParts,\r\n          attribute,\r\n          assign: assignVar,\r\n          transforms,\r\n        });\r\n      }\r\n      i++;\r\n    }\r\n  }\r\n  return instructions;\r\n}\r\n\r\nasync function executeInstructions(instructions, context, $, baseElements) {\r\n  if (!context._excluded) context._excluded = {};\r\n  for (const instr of instructions) {\r\n    if (instr.type === \"extract\") {\r\n      let startingToken = instr.chain[0];\r\n      let elements;\r\n      if (baseElements) {\r\n        elements = baseElements;\r\n      } else if (context[startingToken]) {\r\n        elements = context[startingToken];\r\n      } else {\r\n        elements = $(startingToken).toArray();\r\n      }\r\n      for (let i = 1; i < instr.chain.length; i++) {\r\n        const token = instr.chain[i];\r\n        let newElements = [];\r\n        for (const el of elements) {\r\n          newElements = newElements.concat($(el).find(token).toArray());\r\n        }\r\n        elements = newElements;\r\n      }\r\n      if (instr.attribute) {\r\n        elements = elements.map((el) => $(el).attr(instr.attribute));\r\n      }\r\n      if (instr.transforms && instr.transforms.length > 0) {\r\n        elements = elements.map((val) => {\r\n          let transformed = val;\r\n          for (let { fn, params } of instr.transforms) {\r\n            if (typeof transformFunctions[fn] === \"function\") {\r\n              transformed = transformFunctions[fn](transformed, $, ...params);\r\n            }\r\n          }\r\n          return transformed;\r\n        });\r\n      }\r\n      context[instr.assign] = elements;\r\n      if (instr.exclude) {\r\n        context._excluded[instr.assign] = true;\r\n      }\r\n    } else if (instr.type === \"literal\") {\r\n      let value = instr.literal;\r\n      if (instr.transforms && instr.transforms.length > 0) {\r\n        for (let { fn, params } of instr.transforms) {\r\n          if (typeof transformFunctions[fn] === \"function\") {\r\n            value = transformFunctions[fn](value, $, ...params);\r\n          }\r\n        }\r\n      }\r\n      context[instr.assign] = [value];\r\n      if (instr.exclude) {\r\n        context._excluded[instr.assign] = true;\r\n      }\r\n    } else if (instr.type === \"block\") {\r\n      let blockContext = {};\r\n      blockContext._excluded = {};\r\n      let baseArray = null;\r\n      for (const binstr of instr.instructions) {\r\n        if (binstr.type === \"extract\" || binstr.type === \"literal\") {\r\n          let elems;\r\n          if (binstr.type === \"extract\") {\r\n            let startingToken = binstr.chain[0];\r\n            if (blockContext[startingToken]) {\r\n              elems = blockContext[startingToken];\r\n            } else if (context[startingToken]) {\r\n              elems = context[startingToken];\r\n            } else {\r\n              elems = $(startingToken).toArray();\r\n            }\r\n            for (let i = 1; i < binstr.chain.length; i++) {\r\n              const token = binstr.chain[i];\r\n              let newElems = [];\r\n              for (const el of elems) {\r\n                newElems = newElems.concat($(el).find(token).toArray());\r\n              }\r\n              elems = newElems;\r\n            }\r\n            if (binstr.attribute) {\r\n              elems = elems.map((el) => $(el).attr(binstr.attribute));\r\n            }\r\n            if (binstr.transforms && binstr.transforms.length > 0) {\r\n              elems = elems.map((val) => {\r\n                let transformed = val;\r\n                for (let { fn, params } of binstr.transforms) {\r\n                  if (typeof transformFunctions[fn] === \"function\") {\r\n                    transformed = transformFunctions[fn](transformed, $, ...params);\r\n                  }\r\n                }\r\n                return transformed;\r\n              });\r\n            }\r\n            blockContext[binstr.assign] = elems;\r\n          } else if (binstr.type === \"literal\") {\r\n            let literalVal = binstr.literal;\r\n            if (binstr.transforms && binstr.transforms.length > 0) {\r\n              for (let { fn, params } of binstr.transforms) {\r\n                if (typeof transformFunctions[fn] === \"function\") {\r\n                  literalVal = transformFunctions[fn](literalVal, $, ...params);\r\n                }\r\n              }\r\n            }\r\n            blockContext[binstr.assign] = [literalVal];\r\n          }\r\n          if (binstr.exclude) {\r\n            blockContext._excluded[binstr.assign] = true;\r\n          }\r\n          if (!baseArray) {\r\n            baseArray = blockContext[binstr.assign];\r\n          }\r\n        } else if (binstr.type === \"block\") {\r\n          const nestedResult = await executeInstructions(binstr.instructions, blockContext, $, null);\r\n          blockContext[binstr.assign] = nestedResult;\r\n        }\r\n      }\r\n      let combined = [];\r\n      if (baseArray && Array.isArray(baseArray)) {\r\n        for (let i = 0; i < baseArray.length; i++) {\r\n          let obj = {};\r\n          for (const key in blockContext) {\r\n            if (key === \"_excluded\") continue;\r\n            if (blockContext._excluded && blockContext._excluded[key]) continue;\r\n            const val = blockContext[key];\r\n            obj[key] = Array.isArray(val) ? val[i] : val;\r\n          }\r\n          combined.push(obj);\r\n        }\r\n      } else {\r\n        combined = blockContext;\r\n      }\r\n      context[instr.assign] = combined;\r\n    } else if (instr.type === \"conditional\") {\r\n      let conditionResult = false;\r\n      try {\r\n        conditionResult = new Function(\"context\", \"$\", \"return (\" + instr.condition + \");\")(context, $);\r\n      } catch (e) {\r\n        conditionResult = false;\r\n      }\r\n      if (conditionResult) {\r\n        await executeInstructions(instr.ifInstructions, context, $, baseElements);\r\n      } else if (instr.elseInstructions) {\r\n        await executeInstructions(instr.elseInstructions, context, $, baseElements);\r\n      }\r\n    }\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction mergeResults(resultsArray) {\r\n  let merged = {};\r\n  for (const result of resultsArray) {\r\n    for (let key in result) {\r\n      if (merged[key]) {\r\n        merged[key] = merged[key].concat(result[key]);\r\n      } else {\r\n        merged[key] = result[key];\r\n      }\r\n    }\r\n  }\r\n  return merged;\r\n}\r\n\r\nlet engines = {};\r\nfunction registerPlugin(plugin) {\r\n  if (plugin.engines) {\r\n    for (const name in plugin.engines) {\r\n      engines[name] = plugin.engines[name];\r\n    }\r\n  }\r\n  if (plugin.transformFunctions) {\r\n    for (const tf in plugin.transformFunctions) {\r\n      transformFunctions[tf] = plugin.transformFunctions[tf];\r\n    }\r\n  }\r\n}\r\n\r\nasync function scrape(scriptContent, props = {}) {\r\n  let scriptHash = getScriptHash(scriptContent);\r\n  let { url, config, instructions } = parseScript(scriptContent);\r\n\r\n  url = url.replace(/\\[(\\w+)\\]/g, (match, prop) => {\r\n    if (props[prop] !== undefined) {\r\n      return encodeURIComponent(props[prop]);\r\n    }\r\n    return \"\";\r\n  });\r\n\r\n  let combinedResults = {};\r\n\r\n  let processPage = async (htmlContent) => {\r\n    const local$ = cheerio.load(htmlContent);\r\n    let context = {};\r\n    await executeInstructions(instructions, context, local$, null);\r\n    return cleanResult(context, local$);\r\n  };\r\n\r\n  if (config.engine && config.engine.toLowerCase() === \"puppeteer\") {\r\n    let browser;\r\n    try {\r\n      browser = await puppeteer.launch();\r\n      const page = await browser.newPage();\r\n      await page.goto(url, { waitUntil: \"networkidle2\" });\r\n\r\n      if (config.paginationType?.toLowerCase() === \"scroll\") {\r\n        let pageResults = [];\r\n        const limit = config.paginationLimit ? parseInt(config.paginationLimit) : 5;\r\n        for (let i = 0; i < limit; i++) {\r\n          await page.evaluate(() => window.scrollBy(0, window.innerHeight));\r\n          await page.waitForTimeout(1000);\r\n          let html = await page.content();\r\n          pageResults.push(await processPage(html));\r\n        }\r\n        combinedResults = mergeResults(pageResults);\r\n      } else {\r\n        combinedResults = await processPage(await page.content());\r\n        if (config.paginationNext) {\r\n          let pageCount = 1;\r\n          const limit = config.paginationLimit ? parseInt(config.paginationLimit) : 5;\r\n          const nextSelector = config.paginationNext;\r\n          while (pageCount < limit) {\r\n            const nextPageElement = await page.$(nextSelector);\r\n            if (!nextPageElement) break;\r\n            let nextUrl = await page.evaluate((el) => el.href, nextPageElement);\r\n            await page.goto(nextUrl, { waitUntil: \"networkidle2\" });\r\n            const pageResult = await processPage(await page.content());\r\n            combinedResults = mergeResults([combinedResults, pageResult]);\r\n            pageCount++;\r\n          }\r\n        }\r\n      }\r\n    } finally {\r\n      if (browser) await browser.close();\r\n    }\r\n    return { result: combinedResults, config };\r\n  } else {\r\n    let data = await fetchWithCache(url, scriptHash);\r\n    combinedResults = await processPage(data);\r\n    let $ = cheerio.load(data);\r\n\r\n    if (config.paginationAjax) {\r\n      const limit = config.paginationLimit ? parseInt(config.paginationLimit) : 5;\r\n      let ajaxResults = [];\r\n      const concurrency = config.concurrency ? parseInt(config.concurrency) : 1;\r\n\r\n      if (concurrency > 1) {\r\n        let ajaxPromises = Array.from({ length: limit }, (_, i) =>\r\n          fetchWithCache(config.paginationAjax.replace(\"{page}\", i + 1), scriptHash)\r\n        );\r\n        let pagesHtml = await Promise.all(ajaxPromises);\r\n        ajaxResults = await Promise.all(pagesHtml.map(processPage));\r\n      } else {\r\n        for (let i = 1; i <= limit; i++) {\r\n          let pageData = await fetchWithCache(config.paginationAjax.replace(\"{page}\", i), scriptHash);\r\n          ajaxResults.push(await processPage(pageData));\r\n        }\r\n      }\r\n      combinedResults = mergeResults(ajaxResults);\r\n    } else if (config.paginationNext) {\r\n      let pageCount = 1;\r\n      const limit = config.paginationLimit ? parseInt(config.paginationLimit) : 5;\r\n      const nextSelector = config.paginationNext;\r\n\r\n      while (pageCount < limit) {\r\n        const nextPageElement = $(nextSelector).first();\r\n        if (!nextPageElement || !nextPageElement.attr(\"href\")) break;\r\n        let nextUrl = new URL(nextPageElement.attr(\"href\"), url).toString();\r\n        let nextData = await fetchWithCache(nextUrl, scriptHash);\r\n        const pageResult = await processPage(nextData);\r\n        combinedResults = mergeResults([combinedResults, pageResult]);\r\n        pageCount++;\r\n      }\r\n    }\r\n    return { result: combinedResults, config };\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  scrape,\r\n  parseScript,\r\n  parseInstructions,\r\n  executeInstructions,\r\n  transformFunctions,\r\n  registerPlugin\r\n};\r\n\r\nif (require.main === module) {\r\n  if (process.argv.length < 3) {\r\n    console.error(\"Usage: node index.js <script_file> [prop1=val1 prop2=val2 ...]\");\r\n    process.exit(1);\r\n  }\r\n  \r\n  const script = fs.readFileSync(process.argv[2], \"utf8\");\r\n  let props = {};\r\n  if (process.argv.length > 3) {\r\n    for (let i = 3; i < process.argv.length; i++) {\r\n      const [key, value] = process.argv[i].split(\"=\");\r\n      props[key] = value;\r\n    }\r\n  }\r\n  scrape(script, props)\r\n    .then((result) => {\r\n      // Only final results are printed.\r\n      console.log(JSON.stringify(result, null, 2));\r\n    })\r\n    .catch((err) => {\r\n      // If something goes wrong, it's shown here.\r\n      console.error(err);\r\n    });\r\n}\r\n"],
  "mappings": "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",
  "names": ["parts"]
}
