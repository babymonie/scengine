{
  "version": 3,
  "sources": ["../index.js"],
  "sourcesContent": ["const axios = require(\"axios\");\r\nconst fs = require(\"fs\");\r\nconst cheerio = require(\"cheerio\");\r\nconst { URL } = require(\"url\");\r\nconst crypto = require(\"crypto\"); // For hashing the script\r\nconst requestCache = new Map();\r\nconst DEFAULT_TTL = 1000 * 60 * 5; // 5 minutes\r\n\r\nfunction getScriptHash(scriptContent) {\r\n  return crypto.createHash(\"md5\").update(scriptContent).digest(\"hex\");\r\n}\r\n\r\nfunction getCacheKey(url, scriptHash) {\r\n  return `${url}::${scriptHash}`;\r\n}\r\n\r\nfunction getCached(cacheKey) {\r\n  const entry = requestCache.get(cacheKey);\r\n  if (!entry) return null;\r\n  if (Date.now() > entry.expireAt) {\r\n    requestCache.delete(cacheKey);\r\n    return null;\r\n  }\r\n  return entry.data;\r\n}\r\n\r\nfunction setCached(cacheKey, data, ttl = DEFAULT_TTL) {\r\n  requestCache.set(cacheKey, {\r\n    data,\r\n    expireAt: Date.now() + ttl,\r\n  });\r\n}\r\n\r\nasync function fetchWithCache(url, scriptHash, axiosConfig = {}, ttl = DEFAULT_TTL) {\r\n  const cacheKey = getCacheKey(url, scriptHash);\r\n  const cached = getCached(cacheKey);\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n  const response = await axios.get(url, axiosConfig);\r\n  setCached(cacheKey, response.data, ttl);\r\n  return response.data;\r\n}\r\nconst transformFunctions = {\r\n  trim: (val, $) => (typeof val === \"string\" ? val.trim() : val),\r\n  toLowerCase: (val, $) => (typeof val === \"string\" ? val.toLowerCase() : val),\r\n  toUpperCase: (val, $) => (typeof val === \"string\" ? val.toUpperCase() : val),\r\n  default: (val, $, defaultVal) => (val == null || val === \"\" ? defaultVal : val),\r\n  regex: (val, $, pattern, group = \"0\") => {\r\n    if (typeof val !== \"string\") return val;\r\n    const re = new RegExp(pattern);\r\n    const match = val.match(re);\r\n    if (match) {\r\n      const index = parseInt(group);\r\n      return match[index] || val;\r\n    }\r\n    return val;\r\n  },\r\n  dateParse: (val, $) => {\r\n    const date = new Date(val);\r\n    return isNaN(date.getTime()) ? val : date.toISOString();\r\n  },\r\n  customJS: (val, $, code) => {\r\n    try {\r\n      const fn = new Function(\"value\", code);\r\n      return fn(val);\r\n    } catch (e) {\r\n      return val;\r\n    }\r\n  },\r\n  regexReplace: (val, $, pattern, replacement) => {\r\n    if (typeof val !== \"string\") return val;\r\n    pattern = pattern.replace(/\\\\\\\\/g, '\\\\');\r\n    const re = new RegExp(pattern);\r\n    return val.replace(re, replacement);\r\n  },\r\n};\r\n\r\nfunction cleanResult(value, $) {\r\n  if (Array.isArray(value)) {\r\n    return value.map((item) => cleanResult(item, $));\r\n  } else if (typeof value === \"object\" && value !== null) {\r\n    if (value.type && value.children) {\r\n      return $(value).text();\r\n    }\r\n    let newObj = {};\r\n    for (let key in value) {\r\n      newObj[key] = cleanResult(value[key], $);\r\n    }\r\n    return newObj;\r\n  } else {\r\n    return value;\r\n  }\r\n}\r\n\r\nfunction parseBlock(lines, startIndex) {\r\n  let blockLines = [];\r\n  let braceCount = 1;\r\n  let i = startIndex;\r\n  while (i < lines.length && braceCount > 0) {\r\n    const line = lines[i];\r\n    if (line.endsWith(\"{\")) {\r\n      braceCount++;\r\n      blockLines.push(line);\r\n    } else if (line === \"}\") {\r\n      braceCount--;\r\n      if (braceCount > 0) blockLines.push(line);\r\n    } else {\r\n      blockLines.push(line);\r\n    }\r\n    i++;\r\n  }\r\n  return { blockText: blockLines.join(\"\\n\"), newIndex: i };\r\n}\r\n\r\nfunction parseScript(script) {\r\n  script = script.trim();\r\n  const match = script.match(/^([^\\{]+)\\{([\\s\\S]+)\\}\\s*$/);\r\n  if (!match) {\r\n    throw new Error(\"Invalid script format. Ensure the Scengine is enclosed in { }.\");\r\n  }\r\n  const headerParts = match[1].trim().split(\"|\").map((s) => s.trim());\r\n  const url = headerParts[0];\r\n  const config = {};\r\n  for (let i = 1; i < headerParts.length; i++) {\r\n    const [key, value] = headerParts[i].split(\"=\");\r\n    if (key && value) {\r\n      config[key.trim()] = value.trim();\r\n    }\r\n  }\r\n  const instructionsText = match[2].trim();\r\n  const instructions = parseInstructions(instructionsText);\r\n  return { url, config, instructions };\r\n}\r\n\r\nfunction parseInstructions(text) {\r\n  text = text.replace(/}\\s*else\\s*{/g, \"}\\nelse {\");\r\n  const lines = text\r\n    .split(\"\\n\")\r\n    .map((line) => line.trim())\r\n    .filter((line) => line && !line.startsWith(\"//\"));\r\n\r\n  const instructions = [];\r\n  let i = 0;\r\n  while (i < lines.length) {\r\n    let line = lines[i];\r\n    if (/^if\\s*\\(.*\\)\\s*\\{$/.test(line)) {\r\n      const conditionMatch = line.match(/^if\\s*\\((.*)\\)\\s*\\{$/);\r\n      if (!conditionMatch) throw new Error(`Invalid if condition: ${line}`);\r\n      const condition = conditionMatch[1];\r\n      i++;\r\n      const { blockText, newIndex } = parseBlock(lines, i);\r\n      const ifInstructions = parseInstructions(blockText);\r\n      i = newIndex;\r\n      let elseInstructions = null;\r\n      if (i < lines.length && /^else\\s*\\{$/.test(lines[i])) {\r\n        i++;\r\n        const { blockText: elseBlock, newIndex: elseNewIndex } = parseBlock(lines, i);\r\n        elseInstructions = parseInstructions(elseBlock);\r\n        i = elseNewIndex;\r\n      }\r\n      instructions.push({\r\n        type: \"conditional\",\r\n        condition,\r\n        ifInstructions,\r\n        elseInstructions,\r\n      });\r\n      continue;\r\n    }\r\n    if (line.endsWith(\":{\")) {\r\n      const assignVar = line.slice(0, -2).trim();\r\n      i++;\r\n      const { blockText, newIndex } = parseBlock(lines, i);\r\n      const nestedInstructions = parseInstructions(blockText);\r\n      instructions.push({\r\n        type: \"block\",\r\n        assign: assignVar,\r\n        instructions: nestedInstructions,\r\n      });\r\n      i = newIndex;\r\n      continue;\r\n    }\r\n    {\r\n      let exclude = false;\r\n      if (line.startsWith(\"!\")) {\r\n        exclude = true;\r\n        line = line.slice(1).trim();\r\n      }\r\n      const parts = line.split(\"=\");\r\n      if (parts.length !== 2) {\r\n        throw new Error(`Invalid instruction: ${line}`);\r\n      }\r\n      const lhs = parts[0].trim();\r\n      let assignPart = parts[1].trim();\r\n      let assignVar, transforms = [];\r\n      if (assignPart.includes(\"|\")) {\r\n        const tokens = assignPart.split(\"|\").map((s) => s.trim());\r\n        assignVar = tokens[0];\r\n        transforms = tokens.slice(1).map((token) => {\r\n          const m = token.match(/^(\\w+)(?:\\((.*)\\))?$/);\r\n          if (m) {\r\n            return {\r\n              fn: m[1],\r\n              params: m[2]\r\n                ? m[2].split(\",\").map((s) => s.trim().replace(/^[\"']|[\"']$/g, \"\"))\r\n                : [],\r\n            };\r\n          }\r\n          return { fn: token, params: [] };\r\n        });\r\n      } else {\r\n        assignVar = assignPart;\r\n      }\r\n      let literalValue = null;\r\n      if (\r\n        (lhs.startsWith('\"') && lhs.endsWith('\"')) ||\r\n        (lhs.startsWith(\"'\") && lhs.endsWith(\"'\"))\r\n      ) {\r\n        literalValue = lhs.slice(1, -1);\r\n      }\r\n      let chainParts = null;\r\n      let attribute = null;\r\n      if (!literalValue) {\r\n        const originalChainParts = lhs.split(\">\").map((s) => s.trim());\r\n        chainParts = originalChainParts.map((part) =>\r\n          part.includes(\"..\") ? part.replace(/\\.\\./g, \".\") : part\r\n        );\r\n        const lastTokenOriginal = originalChainParts[originalChainParts.length - 1];\r\n        if (!lastTokenOriginal.startsWith('.') && lastTokenOriginal.includes(\".\")) {\r\n          const parts = lastTokenOriginal.split(\".\");\r\n          chainParts[chainParts.length - 1] = parts[0].trim();\r\n          attribute = parts[1].trim();\r\n        }\r\n      }\r\n      if (literalValue !== null) {\r\n        instructions.push({\r\n          type: \"literal\",\r\n          literal: literalValue,\r\n          assign: assignVar,\r\n          transforms,\r\n          exclude,\r\n        });\r\n      } else {\r\n        instructions.push({\r\n          type: \"extract\",\r\n          exclude,\r\n          chain: chainParts,\r\n          attribute,\r\n          assign: assignVar,\r\n          transforms,\r\n        });\r\n      }\r\n      i++;\r\n    }\r\n  }\r\n  return instructions;\r\n}\r\n\r\nasync function executeInstructions(instructions, context, $, baseElements) {\r\n  if (!context._excluded) context._excluded = {};\r\n  for (const instr of instructions) {\r\n    if (instr.type === \"extract\") {\r\n      let startingToken = instr.chain[0];\r\n      let elements;\r\n      if (baseElements) {\r\n        elements = baseElements;\r\n      } else if (context[startingToken]) {\r\n        elements = context[startingToken];\r\n      } else {\r\n        elements = $(startingToken).toArray();\r\n      }\r\n      for (let i = 1; i < instr.chain.length; i++) {\r\n        const token = instr.chain[i];\r\n        let newElements = [];\r\n        for (const el of elements) {\r\n          newElements = newElements.concat($(el).find(token).toArray());\r\n        }\r\n        elements = newElements;\r\n      }\r\n      if (instr.attribute) {\r\n        elements = elements.map((el) => $(el).attr(instr.attribute));\r\n      }\r\n      if (instr.transforms && instr.transforms.length > 0) {\r\n        elements = elements.map((val) => {\r\n          let transformed = val;\r\n          for (let { fn, params } of instr.transforms) {\r\n            if (typeof transformFunctions[fn] === \"function\") {\r\n              transformed = transformFunctions[fn](transformed, $, ...params);\r\n            }\r\n          }\r\n          return transformed;\r\n        });\r\n      }\r\n      context[instr.assign] = elements;\r\n      if (instr.exclude) {\r\n        context._excluded[instr.assign] = true;\r\n      }\r\n    } else if (instr.type === \"literal\") {\r\n      let value = instr.literal;\r\n      if (instr.transforms && instr.transforms.length > 0) {\r\n        for (let { fn, params } of instr.transforms) {\r\n          if (typeof transformFunctions[fn] === \"function\") {\r\n            value = transformFunctions[fn](value, $, ...params);\r\n          }\r\n        }\r\n      }\r\n      context[instr.assign] = [value];\r\n      if (instr.exclude) {\r\n        context._excluded[instr.assign] = true;\r\n      }\r\n    } else if (instr.type === \"block\") {\r\n      let blockContext = {};\r\n      blockContext._excluded = {};\r\n      let baseArray = null;\r\n      for (const binstr of instr.instructions) {\r\n        if (binstr.type === \"extract\" || binstr.type === \"literal\") {\r\n          let elems;\r\n          if (binstr.type === \"extract\") {\r\n            let startingToken = binstr.chain[0];\r\n            if (blockContext[startingToken]) {\r\n              elems = blockContext[startingToken];\r\n            } else if (context[startingToken]) {\r\n              elems = context[startingToken];\r\n            } else {\r\n              elems = $(startingToken).toArray();\r\n            }\r\n            for (let i = 1; i < binstr.chain.length; i++) {\r\n              const token = binstr.chain[i];\r\n              let newElems = [];\r\n              for (const el of elems) {\r\n                newElems = newElems.concat($(el).find(token).toArray());\r\n              }\r\n              elems = newElems;\r\n            }\r\n            if (binstr.attribute) {\r\n              elems = elems.map((el) => $(el).attr(binstr.attribute));\r\n            }\r\n            if (binstr.transforms && binstr.transforms.length > 0) {\r\n              elems = elems.map((val) => {\r\n                let transformed = val;\r\n                for (let { fn, params } of binstr.transforms) {\r\n                  if (typeof transformFunctions[fn] === \"function\") {\r\n                    transformed = transformFunctions[fn](transformed, $, ...params);\r\n                  }\r\n                }\r\n                return transformed;\r\n              });\r\n            }\r\n            blockContext[binstr.assign] = elems;\r\n          } else if (binstr.type === \"literal\") {\r\n            let literalVal = binstr.literal;\r\n            if (binstr.transforms && binstr.transforms.length > 0) {\r\n              for (let { fn, params } of binstr.transforms) {\r\n                if (typeof transformFunctions[fn] === \"function\") {\r\n                  literalVal = transformFunctions[fn](literalVal, $, ...params);\r\n                }\r\n              }\r\n            }\r\n            blockContext[binstr.assign] = [literalVal];\r\n          }\r\n          if (binstr.exclude) {\r\n            blockContext._excluded[binstr.assign] = true;\r\n          }\r\n          if (!baseArray) {\r\n            baseArray = blockContext[binstr.assign];\r\n          }\r\n        } else if (binstr.type === \"block\") {\r\n          const nestedResult = await executeInstructions(binstr.instructions, blockContext, $, null);\r\n          blockContext[binstr.assign] = nestedResult;\r\n        }\r\n      }\r\n      let combined = [];\r\n      if (baseArray && Array.isArray(baseArray)) {\r\n        for (let i = 0; i < baseArray.length; i++) {\r\n          let obj = {};\r\n          for (const key in blockContext) {\r\n            if (key === \"_excluded\") continue;\r\n            if (blockContext._excluded && blockContext._excluded[key]) continue;\r\n            const val = blockContext[key];\r\n            obj[key] = Array.isArray(val) ? val[i] : val;\r\n          }\r\n          combined.push(obj);\r\n        }\r\n      } else {\r\n        combined = blockContext;\r\n      }\r\n      context[instr.assign] = combined;\r\n    } else if (instr.type === \"conditional\") {\r\n      let conditionResult = false;\r\n      try {\r\n        conditionResult = new Function(\"context\", \"$\", \"return (\" + instr.condition + \");\")(context, $);\r\n      } catch (e) {\r\n        conditionResult = false;\r\n      }\r\n      if (conditionResult) {\r\n        await executeInstructions(instr.ifInstructions, context, $, baseElements);\r\n      } else if (instr.elseInstructions) {\r\n        await executeInstructions(instr.elseInstructions, context, $, baseElements);\r\n      }\r\n    }\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction mergeResults(resultsArray) {\r\n  let merged = {};\r\n  for (const result of resultsArray) {\r\n    for (let key in result) {\r\n      if (merged[key]) {\r\n        merged[key] = merged[key].concat(result[key]);\r\n      } else {\r\n        merged[key] = result[key];\r\n      }\r\n    }\r\n  }\r\n  return merged;\r\n}\r\n\r\nlet engines = {};\r\nfunction registerPlugin(plugin) {\r\n  if (plugin.engines) {\r\n    for (const name in plugin.engines) {\r\n      engines[name] = plugin.engines[name];\r\n    }\r\n  }\r\n  if (plugin.transformFunctions) {\r\n    for (const tf in plugin.transformFunctions) {\r\n      transformFunctions[tf] = plugin.transformFunctions[tf];\r\n    }\r\n  }\r\n}\r\n\r\nasync function scrape(scriptContent, props = {}) {\r\n  let scriptHash = getScriptHash(scriptContent);\r\n  let { url, config, instructions } = parseScript(scriptContent);\r\n\r\n  url = url.replace(/\\[(\\w+)\\]/g, (match, prop) => {\r\n    if (props[prop] !== undefined) {\r\n      return encodeURIComponent(props[prop]);\r\n    }\r\n    return \"\";\r\n  });\r\n\r\n  let combinedResults = {};\r\n\r\n  let processPage = async (htmlContent) => {\r\n    const local$ = cheerio.load(htmlContent);\r\n    let context = {};\r\n    await executeInstructions(instructions, context, local$, null);\r\n    return cleanResult(context, local$);\r\n  };\r\n\r\n  if (config.engine && config.engine.toLowerCase() === \"puppeteer\") {\r\n    let browser;\r\n    try {\r\n      browser = await puppeteer.launch();\r\n      const page = await browser.newPage();\r\n      await page.goto(url, { waitUntil: \"networkidle2\" });\r\n\r\n      if (config.paginationType?.toLowerCase() === \"scroll\") {\r\n        let pageResults = [];\r\n        const limit = config.paginationLimit ? parseInt(config.paginationLimit) : 5;\r\n        for (let i = 0; i < limit; i++) {\r\n          await page.evaluate(() => window.scrollBy(0, window.innerHeight));\r\n          await page.waitForTimeout(1000);\r\n          let html = await page.content();\r\n          pageResults.push(await processPage(html));\r\n        }\r\n        combinedResults = mergeResults(pageResults);\r\n      } else {\r\n        combinedResults = await processPage(await page.content());\r\n        if (config.paginationNext) {\r\n          let pageCount = 1;\r\n          const limit = config.paginationLimit ? parseInt(config.paginationLimit) : 5;\r\n          const nextSelector = config.paginationNext;\r\n          while (pageCount < limit) {\r\n            const nextPageElement = await page.$(nextSelector);\r\n            if (!nextPageElement) break;\r\n            let nextUrl = await page.evaluate((el) => el.href, nextPageElement);\r\n            await page.goto(nextUrl, { waitUntil: \"networkidle2\" });\r\n            const pageResult = await processPage(await page.content());\r\n            combinedResults = mergeResults([combinedResults, pageResult]);\r\n            pageCount++;\r\n          }\r\n        }\r\n      }\r\n    } finally {\r\n      if (browser) await browser.close();\r\n    }\r\n    return { result: combinedResults, config };\r\n  } else {\r\n    let data = await fetchWithCache(url, scriptHash);\r\n    combinedResults = await processPage(data);\r\n    let $ = cheerio.load(data);\r\n\r\n    if (config.paginationAjax) {\r\n      const limit = config.paginationLimit ? parseInt(config.paginationLimit) : 5;\r\n      let ajaxResults = [];\r\n      const concurrency = config.concurrency ? parseInt(config.concurrency) : 1;\r\n\r\n      if (concurrency > 1) {\r\n        let ajaxPromises = Array.from({ length: limit }, (_, i) =>\r\n          fetchWithCache(config.paginationAjax.replace(\"{page}\", i + 1), scriptHash)\r\n        );\r\n        let pagesHtml = await Promise.all(ajaxPromises);\r\n        ajaxResults = await Promise.all(pagesHtml.map(processPage));\r\n      } else {\r\n        for (let i = 1; i <= limit; i++) {\r\n          let pageData = await fetchWithCache(config.paginationAjax.replace(\"{page}\", i), scriptHash);\r\n          ajaxResults.push(await processPage(pageData));\r\n        }\r\n      }\r\n      combinedResults = mergeResults(ajaxResults);\r\n    } else if (config.paginationNext) {\r\n      let pageCount = 1;\r\n      const limit = config.paginationLimit ? parseInt(config.paginationLimit) : 5;\r\n      const nextSelector = config.paginationNext;\r\n\r\n      while (pageCount < limit) {\r\n        const nextPageElement = $(nextSelector).first();\r\n        if (!nextPageElement || !nextPageElement.attr(\"href\")) break;\r\n        let nextUrl = new URL(nextPageElement.attr(\"href\"), url).toString();\r\n        let nextData = await fetchWithCache(nextUrl, scriptHash);\r\n        const pageResult = await processPage(nextData);\r\n        combinedResults = mergeResults([combinedResults, pageResult]);\r\n        pageCount++;\r\n      }\r\n    }\r\n    return { result: combinedResults, config };\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  scrape,\r\n  parseScript,\r\n  parseInstructions,\r\n  executeInstructions,\r\n  transformFunctions,\r\n  registerPlugin\r\n};\r\n\r\nif (require.main === module) {\r\n  const script = fs.readFileSync(process.argv[2], \"utf8\");\r\n  let props = {};\r\n  if (process.argv.length > 3) {\r\n    for (let i = 3; i < process.argv.length; i++) {\r\n      const [key, value] = process.argv[i].split(\"=\");\r\n      props[key] = value;\r\n    }\r\n  }\r\n  scrape(script, props)\r\n    .then((result) => {\r\n      // Only final results are printed.\r\n      console.log(JSON.stringify(result, null, 2));\r\n    })\r\n    .catch((err) => {\r\n      // If something goes wrong, it's shown here.\r\n      console.error(err);\r\n    });\r\n}\r\n"],
  "mappings": "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",
  "names": ["axios", "fs", "cheerio", "URL", "crypto", "requestCache", "DEFAULT_TTL", "getScriptHash", "scriptContent", "getCacheKey", "url", "scriptHash", "getCached", "cacheKey", "entry", "setCached", "data", "ttl", "fetchWithCache", "axiosConfig", "cached", "response", "transformFunctions", "val", "$", "defaultVal", "pattern", "group", "re", "match", "index", "date", "code", "replacement", "cleanResult", "value", "item", "newObj", "key", "parseBlock", "lines", "startIndex", "blockLines", "braceCount", "i", "line", "parseScript", "script", "headerParts", "s", "config", "instructionsText", "instructions", "parseInstructions", "text", "conditionMatch", "condition", "blockText", "newIndex", "ifInstructions", "elseInstructions", "elseBlock", "elseNewIndex", "assignVar", "nestedInstructions", "exclude", "parts", "lhs", "assignPart", "transforms", "tokens", "token", "literalValue", "chainParts", "attribute", "originalChainParts", "part", "lastTokenOriginal", "executeInstructions", "context", "baseElements", "instr", "startingToken", "elements", "newElements", "el", "transformed", "fn", "params", "blockContext", "baseArray", "binstr", "elems", "newElems", "literalVal", "nestedResult", "combined", "obj", "conditionResult", "mergeResults", "resultsArray", "merged", "result", "engines", "registerPlugin", "plugin", "name", "tf", "scrape", "props", "prop", "combinedResults", "processPage", "htmlContent", "local$", "browser", "page", "pageResults", "limit", "html", "pageCount", "nextSelector", "nextPageElement", "nextUrl", "pageResult", "ajaxResults", "ajaxPromises", "_", "pagesHtml", "pageData", "nextData", "err"]
}
