{
  "version": 3,
  "sources": ["../index.js"],
  "sourcesContent": ["const axios = require(\"axios\");\r\nconst fs = require(\"fs\");\r\nconst cheerio = require(\"cheerio\");\r\nconst { URL } = require(\"url\");\r\nconst crypto = require(\"crypto\"); // For hashing the script\r\nconst requestCache = new Map();\r\nconst DEFAULT_TTL = 1000 * 60 * 5; // 5 minutes\r\n\r\nfunction getScriptHash(scriptContent) {\r\n  return crypto.createHash(\"md5\").update(scriptContent).digest(\"hex\");\r\n}\r\n\r\nfunction getCacheKey(url, scriptHash) {\r\n  return `${url}::${scriptHash}`;\r\n}\r\n\r\nfunction getCached(cacheKey) {\r\n  const entry = requestCache.get(cacheKey);\r\n  if (!entry) return null;\r\n  if (Date.now() > entry.expireAt) {\r\n    requestCache.delete(cacheKey);\r\n    return null;\r\n  }\r\n  return entry.data;\r\n}\r\n\r\nfunction setCached(cacheKey, data, ttl = DEFAULT_TTL) {\r\n  requestCache.set(cacheKey, {\r\n    data,\r\n    expireAt: Date.now() + ttl,\r\n  });\r\n}\r\n\r\nasync function fetchWithCache(url, scriptHash, axiosConfig = {}, ttl = DEFAULT_TTL) {\r\n  const cacheKey = getCacheKey(url, scriptHash);\r\n  const cached = getCached(cacheKey);\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n  const response = await axios.get(url, axiosConfig);\r\n  setCached(cacheKey, response.data, ttl);\r\n  return response.data;\r\n}\r\nconst transformFunctions = {\r\n  trim: (val, $) => (typeof val === \"string\" ? val.trim() : val),\r\n  toLowerCase: (val, $) => (typeof val === \"string\" ? val.toLowerCase() : val),\r\n  toUpperCase: (val, $) => (typeof val === \"string\" ? val.toUpperCase() : val),\r\n  default: (val, $, defaultVal) => (val == null || val === \"\" ? defaultVal : val),\r\n  regex: (val, $, pattern, group = \"0\") => {\r\n    if (typeof val !== \"string\") return val;\r\n    const re = new RegExp(pattern);\r\n    const match = val.match(re);\r\n    if (match) {\r\n      const index = parseInt(group);\r\n      return match[index] || val;\r\n    }\r\n    return val;\r\n  },\r\n  dateParse: (val, $) => {\r\n    const date = new Date(val);\r\n    return isNaN(date.getTime()) ? val : date.toISOString();\r\n  },\r\n  customJS: (val, $, code) => {\r\n    try {\r\n      const fn = new Function(\"value\", code);\r\n      return fn(val);\r\n    } catch (e) {\r\n      return val;\r\n    }\r\n  },\r\n  regexReplace: (val, $, pattern, replacement) => {\r\n    if (typeof val !== \"string\") return val;\r\n    pattern = pattern.replace(/\\\\\\\\/g, '\\\\');\r\n    const re = new RegExp(pattern);\r\n    return val.replace(re, replacement);\r\n  },\r\n};\r\n\r\nfunction cleanResult(value, $) {\r\n  if (Array.isArray(value)) {\r\n    return value.map((item) => cleanResult(item, $));\r\n  } else if (typeof value === \"object\" && value !== null) {\r\n    if (value.type && value.children) {\r\n      return $(value).text();\r\n    }\r\n    let newObj = {};\r\n    for (let key in value) {\r\n      newObj[key] = cleanResult(value[key], $);\r\n    }\r\n    return newObj;\r\n  } else {\r\n    return value;\r\n  }\r\n}\r\n\r\nfunction parseBlock(lines, startIndex) {\r\n  let blockLines = [];\r\n  let braceCount = 1;\r\n  let i = startIndex;\r\n  while (i < lines.length && braceCount > 0) {\r\n    const line = lines[i];\r\n    if (line.endsWith(\"{\")) {\r\n      braceCount++;\r\n      blockLines.push(line);\r\n    } else if (line === \"}\") {\r\n      braceCount--;\r\n      if (braceCount > 0) blockLines.push(line);\r\n    } else {\r\n      blockLines.push(line);\r\n    }\r\n    i++;\r\n  }\r\n  return { blockText: blockLines.join(\"\\n\"), newIndex: i };\r\n}\r\n\r\nfunction parseScript(script) {\r\n  script = script.trim();\r\n  const match = script.match(/^([^\\{]+)\\{([\\s\\S]+)\\}\\s*$/);\r\n  if (!match) {\r\n    throw new Error(\"Invalid script format. Ensure the Scengine is enclosed in { }.\");\r\n  }\r\n  const headerParts = match[1].trim().split(\"|\").map((s) => s.trim());\r\n  const url = headerParts[0];\r\n  const config = {};\r\n  for (let i = 1; i < headerParts.length; i++) {\r\n    const [key, value] = headerParts[i].split(\"=\");\r\n    if (key && value) {\r\n      config[key.trim()] = value.trim();\r\n    }\r\n  }\r\n  const instructionsText = match[2].trim();\r\n  const instructions = parseInstructions(instructionsText);\r\n  return { url, config, instructions };\r\n}\r\n\r\nfunction parseInstructions(text) {\r\n  text = text.replace(/}\\s*else\\s*{/g, \"}\\nelse {\");\r\n  const lines = text\r\n    .split(\"\\n\")\r\n    .map((line) => line.trim())\r\n    .filter((line) => line && !line.startsWith(\"//\"));\r\n\r\n  const instructions = [];\r\n  let i = 0;\r\n  while (i < lines.length) {\r\n    let line = lines[i];\r\n    if (/^if\\s*\\(.*\\)\\s*\\{$/.test(line)) {\r\n      const conditionMatch = line.match(/^if\\s*\\((.*)\\)\\s*\\{$/);\r\n      if (!conditionMatch) throw new Error(`Invalid if condition: ${line}`);\r\n      const condition = conditionMatch[1];\r\n      i++;\r\n      const { blockText, newIndex } = parseBlock(lines, i);\r\n      const ifInstructions = parseInstructions(blockText);\r\n      i = newIndex;\r\n      let elseInstructions = null;\r\n      if (i < lines.length && /^else\\s*\\{$/.test(lines[i])) {\r\n        i++;\r\n        const { blockText: elseBlock, newIndex: elseNewIndex } = parseBlock(lines, i);\r\n        elseInstructions = parseInstructions(elseBlock);\r\n        i = elseNewIndex;\r\n      }\r\n      instructions.push({\r\n        type: \"conditional\",\r\n        condition,\r\n        ifInstructions,\r\n        elseInstructions,\r\n      });\r\n      continue;\r\n    }\r\n    if (line.endsWith(\":{\")) {\r\n      const assignVar = line.slice(0, -2).trim();\r\n      i++;\r\n      const { blockText, newIndex } = parseBlock(lines, i);\r\n      const nestedInstructions = parseInstructions(blockText);\r\n      instructions.push({\r\n        type: \"block\",\r\n        assign: assignVar,\r\n        instructions: nestedInstructions,\r\n      });\r\n      i = newIndex;\r\n      continue;\r\n    }\r\n    {\r\n      let exclude = false;\r\n      if (line.startsWith(\"!\")) {\r\n        exclude = true;\r\n        line = line.slice(1).trim();\r\n      }\r\n      const parts = line.split(\"=\");\r\n      if (parts.length !== 2) {\r\n        throw new Error(`Invalid instruction: ${line}`);\r\n      }\r\n      const lhs = parts[0].trim();\r\n      let assignPart = parts[1].trim();\r\n      let assignVar, transforms = [];\r\n      if (assignPart.includes(\"|\")) {\r\n        const tokens = assignPart.split(\"|\").map((s) => s.trim());\r\n        assignVar = tokens[0];\r\n        transforms = tokens.slice(1).map((token) => {\r\n          const m = token.match(/^(\\w+)(?:\\((.*)\\))?$/);\r\n          if (m) {\r\n            return {\r\n              fn: m[1],\r\n              params: m[2]\r\n                ? m[2].split(\",\").map((s) => s.trim().replace(/^[\"']|[\"']$/g, \"\"))\r\n                : [],\r\n            };\r\n          }\r\n          return { fn: token, params: [] };\r\n        });\r\n      } else {\r\n        assignVar = assignPart;\r\n      }\r\n      let literalValue = null;\r\n      if (\r\n        (lhs.startsWith('\"') && lhs.endsWith('\"')) ||\r\n        (lhs.startsWith(\"'\") && lhs.endsWith(\"'\"))\r\n      ) {\r\n        literalValue = lhs.slice(1, -1);\r\n      }\r\n      let chainParts = null;\r\n      let attribute = null;\r\n      if (!literalValue) {\r\n        const originalChainParts = lhs.split(\">\").map((s) => s.trim());\r\n        chainParts = originalChainParts.map((part) =>\r\n          part.includes(\"..\") ? part.replace(/\\.\\./g, \".\") : part\r\n        );\r\n        const lastTokenOriginal = originalChainParts[originalChainParts.length - 1];\r\n        if (!lastTokenOriginal.startsWith('.') && lastTokenOriginal.includes(\".\")) {\r\n          const parts = lastTokenOriginal.split(\".\");\r\n          chainParts[chainParts.length - 1] = parts[0].trim();\r\n          attribute = parts[1].trim();\r\n        }\r\n      }\r\n      if (literalValue !== null) {\r\n        instructions.push({\r\n          type: \"literal\",\r\n          literal: literalValue,\r\n          assign: assignVar,\r\n          transforms,\r\n          exclude,\r\n        });\r\n      } else {\r\n        instructions.push({\r\n          type: \"extract\",\r\n          exclude,\r\n          chain: chainParts,\r\n          attribute,\r\n          assign: assignVar,\r\n          transforms,\r\n        });\r\n      }\r\n      i++;\r\n    }\r\n  }\r\n  return instructions;\r\n}\r\n\r\nasync function executeInstructions(instructions, context, $, baseElements) {\r\n  if (!context._excluded) context._excluded = {};\r\n  for (const instr of instructions) {\r\n    if (instr.type === \"extract\") {\r\n      let startingToken = instr.chain[0];\r\n      let elements;\r\n      if (baseElements) {\r\n        elements = baseElements;\r\n      } else if (context[startingToken]) {\r\n        elements = context[startingToken];\r\n      } else {\r\n        elements = $(startingToken).toArray();\r\n      }\r\n      for (let i = 1; i < instr.chain.length; i++) {\r\n        const token = instr.chain[i];\r\n        let newElements = [];\r\n        for (const el of elements) {\r\n          newElements = newElements.concat($(el).find(token).toArray());\r\n        }\r\n        elements = newElements;\r\n      }\r\n      if (instr.attribute) {\r\n        elements = elements.map((el) => $(el).attr(instr.attribute));\r\n      }\r\n      if (instr.transforms && instr.transforms.length > 0) {\r\n        elements = elements.map((val) => {\r\n          let transformed = val;\r\n          for (let { fn, params } of instr.transforms) {\r\n            if (typeof transformFunctions[fn] === \"function\") {\r\n              transformed = transformFunctions[fn](transformed, $, ...params);\r\n            }\r\n          }\r\n          return transformed;\r\n        });\r\n      }\r\n      context[instr.assign] = elements;\r\n      if (instr.exclude) {\r\n        context._excluded[instr.assign] = true;\r\n      }\r\n    } else if (instr.type === \"literal\") {\r\n      let value = instr.literal;\r\n      if (instr.transforms && instr.transforms.length > 0) {\r\n        for (let { fn, params } of instr.transforms) {\r\n          if (typeof transformFunctions[fn] === \"function\") {\r\n            value = transformFunctions[fn](value, $, ...params);\r\n          }\r\n        }\r\n      }\r\n      context[instr.assign] = [value];\r\n      if (instr.exclude) {\r\n        context._excluded[instr.assign] = true;\r\n      }\r\n    } else if (instr.type === \"block\") {\r\n      let blockContext = {};\r\n      blockContext._excluded = {};\r\n      let baseArray = null;\r\n      for (const binstr of instr.instructions) {\r\n        if (binstr.type === \"extract\" || binstr.type === \"literal\") {\r\n          let elems;\r\n          if (binstr.type === \"extract\") {\r\n            let startingToken = binstr.chain[0];\r\n            if (blockContext[startingToken]) {\r\n              elems = blockContext[startingToken];\r\n            } else if (context[startingToken]) {\r\n              elems = context[startingToken];\r\n            } else {\r\n              elems = $(startingToken).toArray();\r\n            }\r\n            for (let i = 1; i < binstr.chain.length; i++) {\r\n              const token = binstr.chain[i];\r\n              let newElems = [];\r\n              for (const el of elems) {\r\n                newElems = newElems.concat($(el).find(token).toArray());\r\n              }\r\n              elems = newElems;\r\n            }\r\n            if (binstr.attribute) {\r\n              elems = elems.map((el) => $(el).attr(binstr.attribute));\r\n            }\r\n            if (binstr.transforms && binstr.transforms.length > 0) {\r\n              elems = elems.map((val) => {\r\n                let transformed = val;\r\n                for (let { fn, params } of binstr.transforms) {\r\n                  if (typeof transformFunctions[fn] === \"function\") {\r\n                    transformed = transformFunctions[fn](transformed, $, ...params);\r\n                  }\r\n                }\r\n                return transformed;\r\n              });\r\n            }\r\n            blockContext[binstr.assign] = elems;\r\n          } else if (binstr.type === \"literal\") {\r\n            let literalVal = binstr.literal;\r\n            if (binstr.transforms && binstr.transforms.length > 0) {\r\n              for (let { fn, params } of binstr.transforms) {\r\n                if (typeof transformFunctions[fn] === \"function\") {\r\n                  literalVal = transformFunctions[fn](literalVal, $, ...params);\r\n                }\r\n              }\r\n            }\r\n            blockContext[binstr.assign] = [literalVal];\r\n          }\r\n          if (binstr.exclude) {\r\n            blockContext._excluded[binstr.assign] = true;\r\n          }\r\n          if (!baseArray) {\r\n            baseArray = blockContext[binstr.assign];\r\n          }\r\n        } else if (binstr.type === \"block\") {\r\n          const nestedResult = await executeInstructions(binstr.instructions, blockContext, $, null);\r\n          blockContext[binstr.assign] = nestedResult;\r\n        }\r\n      }\r\n      let combined = [];\r\n      if (baseArray && Array.isArray(baseArray)) {\r\n        for (let i = 0; i < baseArray.length; i++) {\r\n          let obj = {};\r\n          for (const key in blockContext) {\r\n            if (key === \"_excluded\") continue;\r\n            if (blockContext._excluded && blockContext._excluded[key]) continue;\r\n            const val = blockContext[key];\r\n            obj[key] = Array.isArray(val) ? val[i] : val;\r\n          }\r\n          combined.push(obj);\r\n        }\r\n      } else {\r\n        combined = blockContext;\r\n      }\r\n      context[instr.assign] = combined;\r\n    } else if (instr.type === \"conditional\") {\r\n      let conditionResult = false;\r\n      try {\r\n        conditionResult = new Function(\"context\", \"$\", \"return (\" + instr.condition + \");\")(context, $);\r\n      } catch (e) {\r\n        conditionResult = false;\r\n      }\r\n      if (conditionResult) {\r\n        await executeInstructions(instr.ifInstructions, context, $, baseElements);\r\n      } else if (instr.elseInstructions) {\r\n        await executeInstructions(instr.elseInstructions, context, $, baseElements);\r\n      }\r\n    }\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction mergeResults(resultsArray) {\r\n  let merged = {};\r\n  for (const result of resultsArray) {\r\n    for (let key in result) {\r\n      if (merged[key]) {\r\n        merged[key] = merged[key].concat(result[key]);\r\n      } else {\r\n        merged[key] = result[key];\r\n      }\r\n    }\r\n  }\r\n  return merged;\r\n}\r\n\r\nlet engines = {};\r\nfunction registerPlugin(plugin) {\r\n  if (plugin.engines) {\r\n    for (const name in plugin.engines) {\r\n      engines[name] = plugin.engines[name];\r\n    }\r\n  }\r\n  if (plugin.transformFunctions) {\r\n    for (const tf in plugin.transformFunctions) {\r\n      transformFunctions[tf] = plugin.transformFunctions[tf];\r\n    }\r\n  }\r\n}\r\n\r\nasync function scrape(scriptContent, props = {}) {\r\n  let scriptHash = getScriptHash(scriptContent);\r\n  let { url, config, instructions } = parseScript(scriptContent);\r\n\r\n  url = url.replace(/\\[(\\w+)\\]/g, (match, prop) => {\r\n    if (props[prop] !== undefined) {\r\n      return encodeURIComponent(props[prop]);\r\n    }\r\n    return \"\";\r\n  });\r\n\r\n  let combinedResults = {};\r\n\r\n  let processPage = async (htmlContent) => {\r\n    const local$ = cheerio.load(htmlContent);\r\n    let context = {};\r\n    await executeInstructions(instructions, context, local$, null);\r\n    return cleanResult(context, local$);\r\n  };\r\n\r\n  if (config.engine && config.engine.toLowerCase() === \"puppeteer\") {\r\n    let browser;\r\n    try {\r\n      browser = await puppeteer.launch();\r\n      const page = await browser.newPage();\r\n      await page.goto(url, { waitUntil: \"networkidle2\" });\r\n\r\n      if (config.paginationType?.toLowerCase() === \"scroll\") {\r\n        let pageResults = [];\r\n        const limit = config.paginationLimit ? parseInt(config.paginationLimit) : 5;\r\n        for (let i = 0; i < limit; i++) {\r\n          await page.evaluate(() => window.scrollBy(0, window.innerHeight));\r\n          await page.waitForTimeout(1000);\r\n          let html = await page.content();\r\n          pageResults.push(await processPage(html));\r\n        }\r\n        combinedResults = mergeResults(pageResults);\r\n      } else {\r\n        combinedResults = await processPage(await page.content());\r\n        if (config.paginationNext) {\r\n          let pageCount = 1;\r\n          const limit = config.paginationLimit ? parseInt(config.paginationLimit) : 5;\r\n          const nextSelector = config.paginationNext;\r\n          while (pageCount < limit) {\r\n            const nextPageElement = await page.$(nextSelector);\r\n            if (!nextPageElement) break;\r\n            let nextUrl = await page.evaluate((el) => el.href, nextPageElement);\r\n            await page.goto(nextUrl, { waitUntil: \"networkidle2\" });\r\n            const pageResult = await processPage(await page.content());\r\n            combinedResults = mergeResults([combinedResults, pageResult]);\r\n            pageCount++;\r\n          }\r\n        }\r\n      }\r\n    } finally {\r\n      if (browser) await browser.close();\r\n    }\r\n    return { result: combinedResults, config };\r\n  } else {\r\n    let data = await fetchWithCache(url, scriptHash);\r\n    combinedResults = await processPage(data);\r\n    let $ = cheerio.load(data);\r\n\r\n    if (config.paginationAjax) {\r\n      const limit = config.paginationLimit ? parseInt(config.paginationLimit) : 5;\r\n      let ajaxResults = [];\r\n      const concurrency = config.concurrency ? parseInt(config.concurrency) : 1;\r\n\r\n      if (concurrency > 1) {\r\n        let ajaxPromises = Array.from({ length: limit }, (_, i) =>\r\n          fetchWithCache(config.paginationAjax.replace(\"{page}\", i + 1), scriptHash)\r\n        );\r\n        let pagesHtml = await Promise.all(ajaxPromises);\r\n        ajaxResults = await Promise.all(pagesHtml.map(processPage));\r\n      } else {\r\n        for (let i = 1; i <= limit; i++) {\r\n          let pageData = await fetchWithCache(config.paginationAjax.replace(\"{page}\", i), scriptHash);\r\n          ajaxResults.push(await processPage(pageData));\r\n        }\r\n      }\r\n      combinedResults = mergeResults(ajaxResults);\r\n    } else if (config.paginationNext) {\r\n      let pageCount = 1;\r\n      const limit = config.paginationLimit ? parseInt(config.paginationLimit) : 5;\r\n      const nextSelector = config.paginationNext;\r\n\r\n      while (pageCount < limit) {\r\n        const nextPageElement = $(nextSelector).first();\r\n        if (!nextPageElement || !nextPageElement.attr(\"href\")) break;\r\n        let nextUrl = new URL(nextPageElement.attr(\"href\"), url).toString();\r\n        let nextData = await fetchWithCache(nextUrl, scriptHash);\r\n        const pageResult = await processPage(nextData);\r\n        combinedResults = mergeResults([combinedResults, pageResult]);\r\n        pageCount++;\r\n      }\r\n    }\r\n    return { result: combinedResults, config };\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  scrape,\r\n  parseScript,\r\n  parseInstructions,\r\n  executeInstructions,\r\n  transformFunctions,\r\n  registerPlugin\r\n};\r\n\r\nif (require.main === module) {\r\n  if (process.argv.length < 3) {\r\n    console.error(\"Usage: node index.js <script_file> [prop1=val1 prop2=val2 ...]\");\r\n    process.exit(1);\r\n  }\r\n  \r\n  const script = fs.readFileSync(process.argv[2], \"utf8\");\r\n  let props = {};\r\n  if (process.argv.length > 3) {\r\n    for (let i = 3; i < process.argv.length; i++) {\r\n      const [key, value] = process.argv[i].split(\"=\");\r\n      props[key] = value;\r\n    }\r\n  }\r\n  scrape(script, props)\r\n    .then((result) => {\r\n      // Only final results are printed.\r\n      console.log(JSON.stringify(result, null, 2));\r\n    })\r\n    .catch((err) => {\r\n      // If something goes wrong, it's shown here.\r\n      console.error(err);\r\n    });\r\n}\r\n"],
  "mappings": "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",
  "names": ["parts"]
}
